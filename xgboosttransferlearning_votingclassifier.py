# -*- coding: utf-8 -*-
"""XGBoostTransferLearning_VotingClassifier.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F-SsJh8PV_QVos4ubKF8pbXTMxrUEV9u
"""

import zipfile
with zipfile.ZipFile('/content/archive (1) (1).zip', 'r') as zip_ref:
    zip_ref.extractall('/content/')

pip install DeepFace

pip install scikit-learn

pip install tensorflow keras scikit-learn xgboost

import os
import numpy as np
import cv2
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import confusion_matrix, classification_report, accuracy_score
from sklearn.ensemble import VotingClassifier
from xgboost import XGBClassifier
from tensorflow.keras.applications import VGG16
from tensorflow.keras.layers import Dense, Flatten
from tensorflow.keras.models import Model
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.utils import to_categorical
from sklearn.svm import SVC

# ---- Helper Functions ----
def load_images_for_model(folder, target_size=(48, 48)):
    images = []
    labels = []
    for label in os.listdir(folder):
        label_path = os.path.join(folder, label)
        for filename in os.listdir(label_path):
            img_path = os.path.join(label_path, filename)
            img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
            img = cv2.resize(img, target_size)
            if img is not None:
                images.append(img)
                labels.append(label)
    return np.array(images), np.array(labels)

def evaluate_model(model, X_test, y_test, model_name="Model", is_transfer_learning=False):
    if is_transfer_learning:
        y_pred_prob = model.predict(X_test)
        y_pred = np.argmax(y_pred_prob, axis=1)
    else:
        y_pred = model.predict(X_test)

    accuracy = accuracy_score(y_test, y_pred)
    print(f"{model_name} Accuracy: {accuracy * 100:.2f}%")

    cm = confusion_matrix(y_test, y_pred)
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
    plt.title(f"{model_name} Confusion Matrix")
    plt.show()

    print("\nClassification Report:\n", classification_report(y_test, y_pred, target_names=label_encoder.classes_))

    return y_pred

def plot_actual_vs_predicted(y_true, y_pred, title):
    actual_counts = np.unique(y_true, return_counts=True)[1]
    predicted_counts = np.unique(y_pred, return_counts=True)[1]

    emotions = label_encoder.classes_

    fig, ax = plt.subplots(figsize=(10, 6))
    ax.bar(emotions, actual_counts, alpha=0.6, label='Actual')
    ax.bar(emotions, predicted_counts, alpha=0.6, label='Predicted')
    plt.title(f"Actual vs Predicted: {title}")
    plt.xlabel("Emotions")
    plt.ylabel("Count")
    plt.legend()
    plt.show()

def preprocess_image(image_path, target_size=(48, 48)):
    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    img = cv2.resize(img, target_size)
    img = img.astype('float32') / 255.0
    return img.reshape(1, target_size[0], target_size[1], 1)

def predict_single_image(image_path, model, is_transfer_learning=False):
    img = preprocess_image(image_path)
    if is_transfer_learning:
        img = np.repeat(img, 3, axis=-1)  # Convert grayscale to RGB for transfer learning models
        y_pred_prob = model.predict(img)
        y_pred = np.argmax(y_pred_prob, axis=1)
    else:
        y_pred = model.predict(img)
    return label_encoder.inverse_transform(y_pred)[0]

# ---- Load Data ----
train_dir = '/content/train'
val_dir = '/content/test'
X_train, y_train = load_images_for_model(train_dir)
X_test, y_test = load_images_for_model(val_dir)

# Normalize data
X_train = X_train.astype('float32') / 255.0
X_test = X_test.astype('float32') / 255.0

# Encode labels
label_encoder = LabelEncoder()
y_train_encoded = label_encoder.fit_transform(y_train)
y_test_encoded = label_encoder.transform(y_test)
y_train_encoded_categorical = to_categorical(y_train_encoded)
y_test_encoded_categorical = to_categorical(y_test_encoded)

# ---- Transfer Learning with VGG16 ----
def build_transfer_learning_model():
    vgg_base = VGG16(weights='imagenet', include_top=False, input_shape=(48, 48, 3))
    for layer in vgg_base.layers:
        layer.trainable = False

    x = Flatten()(vgg_base.output)
    x = Dense(128, activation='relu')(x)
    output = Dense(len(np.unique(y_train_encoded)), activation='softmax')(x)
    model = Model(inputs=vgg_base.input, outputs=output)
    model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
    return model

# Adjust input dimensions for VGG16 (convert grayscale to RGB)
X_train_rgb = np.repeat(X_train.reshape(-1, 48, 48, 1), 3, axis=-1)
X_test_rgb = np.repeat(X_test.reshape(-1, 48, 48, 1), 3, axis=-1)

transfer_model = build_transfer_learning_model()
transfer_model.fit(X_train_rgb, y_train_encoded_categorical, epochs=50, validation_data=(X_test_rgb, y_test_encoded_categorical))

y_pred_transfer = evaluate_model(transfer_model, X_test_rgb, y_test_encoded, "Transfer Learning (VGG16)", is_transfer_learning=True)
plot_actual_vs_predicted(y_test_encoded, y_pred_transfer, "Transfer Learning")

# ---- XGBoost Classifier ----
xgb = XGBClassifier()
xgb.fit(X_train.reshape(-1, 48*48), y_train_encoded)
y_pred_xgb = evaluate_model(xgb, X_test.reshape(-1, 48*48), y_test_encoded, "XGBoost")
plot_actual_vs_predicted(y_test_encoded, y_pred_xgb, "XGBoost")

# ---- Voting Classifier ----
voting_clf = VotingClassifier(estimators=[('xgb', xgb), ('svc', SVC(probability=True))], voting='soft')
voting_clf.fit(X_train.reshape(-1, 48*48), y_train_encoded)
y_pred_voting = evaluate_model(voting_clf, X_test.reshape(-1, 48*48), y_test_encoded, "Voting Classifier")
plot_actual_vs_predicted(y_test_encoded, y_pred_voting, "Voting Classifier")

# ---- Test Single Image ----
uploaded_image_path = '/content/Training_1206.jpg'  # Update to your image path
predicted_emotion_transfer = predict_single_image(uploaded_image_path, transfer_model, is_transfer_learning=True)
predicted_emotion_xgb = predict_single_image(uploaded_image_path, xgb)
predicted_emotion_voting = predict_single_image(uploaded_image_path, voting_clf)

print(f"Predicted Emotion (Transfer Learning): {predicted_emotion_transfer}")
print(f"Predicted Emotion (XGBoost): {predicted_emotion_xgb}")
print(f"Predicted Emotion (Voting Classifier): {predicted_emotion_voting}")